# Use SkyDNS to resolve host name within k8s.
#
# All requests must explicitly declare namespace, we need this so that this
# one single proxy can fans out to support all namespaces in the cluster.
#
# Here we cache DNS results only for a short duration, as in k8s users will
# definitely tear down and recreate k8s Service on a regular basis, which
# means that it will get a new IP upon restart.
resolver 10.3.0.10 valid=5s;
access_log on;
proxy_redirect off;

# External requests will come in the form
# http://namespace1.localhost.api.no/**
server {
    server_name ~^(?<namespace>[^\.]+)\.localhost\.api\.no$;

    # case 1: REST API
    location ~ ^/api/(?<appname>[^/]*?)/.*$ {
        proxy_pass http://$appname.$namespace.svc.cluster.local;
    }

    # case 2: webapp
    location ~ ^/(?<appname>[^/]*?)/(?<path>.*)$ {
        proxy_pass http://$appname.$namespace.svc.cluster.local;
    }
}

# Internal request will come in the form
# http://svc-proxy.default.svc.cluster.local/**
server {
    server_name svc-proxy.default.svc.cluster.local;

    # case 1: REST API
    location ~ ^/(?<namespace>[^/]*?)/api/(?<appname>[^/]*?)/(?<path>.*)$ {
        rewrite .* /api/$appname/$path break;
        proxy_pass http://$appname.$namespace.svc.cluster.local;
    }

    # case 2: webapp
    location ~ ^/(?<namespace>[^/]*?)/(?<appname>[^/]*?)/(?<path>.*)$ {
        rewrite .* /$appname/$path break;
        proxy_pass http://$appname.$namespace.svc.cluster.local;
    }
}
